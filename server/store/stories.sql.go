// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stories.sql

package store

import (
	"context"
	"strings"
)

const clearRanks = `-- name: ClearRanks :exec
UPDATE stories SET rank = NULL
`

func (q *Queries) ClearRanks(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, clearRanks)
	return err
}

const countCommentsForStory = `-- name: CountCommentsForStory :one
SELECT COUNT(*) FROM comments WHERE story_id = ?
`

func (q *Queries) CountCommentsForStory(ctx context.Context, db DBTX, storyID int) (int, error) {
	row := db.QueryRowContext(ctx, countCommentsForStory, storyID)
	var count int
	err := row.Scan(&count)
	return count, err
}

const countRankedStories = `-- name: CountRankedStories :one
SELECT COUNT(*) FROM stories WHERE rank IS NOT NULL
`

func (q *Queries) CountRankedStories(ctx context.Context, db DBTX) (int, error) {
	row := db.QueryRowContext(ctx, countRankedStories)
	var count int
	err := row.Scan(&count)
	return count, err
}

const countStories = `-- name: CountStories :one
SELECT COUNT(*) FROM stories
`

func (q *Queries) CountStories(ctx context.Context, db DBTX) (int, error) {
	row := db.QueryRowContext(ctx, countStories)
	var count int
	err := row.Scan(&count)
	return count, err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories WHERE id = ?
`

func (q *Queries) DeleteStory(ctx context.Context, db DBTX, id int) error {
	_, err := db.ExecContext(ctx, deleteStory, id)
	return err
}

const getStoriesByIDs = `-- name: GetStoriesByIDs :many
SELECT id, title, url, text, score, by, time, descendants, type, fetched_at, rank, dead
FROM stories WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetStoriesByIDs(ctx context.Context, db DBTX, ids []int) ([]*Story, error) {
	query := getStoriesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.URL,
			&i.Text,
			&i.Score,
			&i.By,
			&i.Time,
			&i.Descendants,
			&i.Type,
			&i.FetchedAt,
			&i.Rank,
			&i.Dead,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT id, title, url, text, score, by, time, descendants, type, fetched_at, rank, dead
FROM stories WHERE id = ?
`

func (q *Queries) GetStoryByID(ctx context.Context, db DBTX, id int) (*Story, error) {
	row := db.QueryRowContext(ctx, getStoryByID, id)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.URL,
		&i.Text,
		&i.Score,
		&i.By,
		&i.Time,
		&i.Descendants,
		&i.Type,
		&i.FetchedAt,
		&i.Rank,
		&i.Dead,
	)
	return &i, err
}

const getStoryFetchedAt = `-- name: GetStoryFetchedAt :one
SELECT fetched_at FROM stories WHERE id = ?
`

func (q *Queries) GetStoryFetchedAt(ctx context.Context, db DBTX, id int) (int64, error) {
	row := db.QueryRowContext(ctx, getStoryFetchedAt, id)
	var fetched_at int64
	err := row.Scan(&fetched_at)
	return fetched_at, err
}

const listStoriesByRank = `-- name: ListStoriesByRank :many
SELECT id, title, url, text, score, by, time, descendants, type, fetched_at, rank, dead
FROM stories WHERE rank IS NOT NULL
ORDER BY rank ASC
LIMIT ? OFFSET ?
`

type ListStoriesByRankParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

func (q *Queries) ListStoriesByRank(ctx context.Context, db DBTX, arg ListStoriesByRankParams) ([]*Story, error) {
	rows, err := db.QueryContext(ctx, listStoriesByRank, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.URL,
			&i.Text,
			&i.Score,
			&i.By,
			&i.Time,
			&i.Descendants,
			&i.Type,
			&i.FetchedAt,
			&i.Rank,
			&i.Dead,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByTimeRange = `-- name: ListStoriesByTimeRange :many
SELECT id, title, url, text, score, by, time, descendants, type, fetched_at, rank, dead
FROM stories WHERE time >= ? AND time < ?
ORDER BY time DESC
`

type ListStoriesByTimeRangeParams struct {
	Time   int64 `json:"time"`
	Time_2 int64 `json:"time_2"`
}

func (q *Queries) ListStoriesByTimeRange(ctx context.Context, db DBTX, arg ListStoriesByTimeRangeParams) ([]*Story, error) {
	rows, err := db.QueryContext(ctx, listStoriesByTimeRange, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.URL,
			&i.Text,
			&i.Score,
			&i.By,
			&i.Time,
			&i.Descendants,
			&i.Type,
			&i.FetchedAt,
			&i.Rank,
			&i.Dead,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const maxFetchedAt = `-- name: MaxFetchedAt :one
SELECT fetched_at FROM stories ORDER BY fetched_at DESC LIMIT 1
`

func (q *Queries) MaxFetchedAt(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, maxFetchedAt)
	var fetched_at int64
	err := row.Scan(&fetched_at)
	return fetched_at, err
}

const oldOffPageStoryIDs = `-- name: OldOffPageStoryIDs :many
SELECT s.id FROM stories s
WHERE s.rank IS NULL
AND s.fetched_at < ?
AND NOT EXISTS (SELECT 1 FROM rankings r WHERE r.story_id = s.id)
`

func (q *Queries) OldOffPageStoryIDs(ctx context.Context, db DBTX, fetchedAt int64) ([]int, error) {
	rows, err := db.QueryContext(ctx, oldOffPageStoryIDs, fetchedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int{}
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setRank = `-- name: SetRank :exec
UPDATE stories SET rank = ? WHERE id = ?
`

type SetRankParams struct {
	Rank *int `json:"rank"`
	ID   int  `json:"id"`
}

func (q *Queries) SetRank(ctx context.Context, db DBTX, arg SetRankParams) error {
	_, err := db.ExecContext(ctx, setRank, arg.Rank, arg.ID)
	return err
}

const storyExists = `-- name: StoryExists :one
SELECT COUNT(*) FROM stories WHERE id = ?
`

func (q *Queries) StoryExists(ctx context.Context, db DBTX, id int) (int, error) {
	row := db.QueryRowContext(ctx, storyExists, id)
	var count int
	err := row.Scan(&count)
	return count, err
}

const upsertStory = `-- name: UpsertStory :exec
INSERT INTO stories (id, title, url, text, score, by, time, descendants, type, fetched_at, rank, dead)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    title=excluded.title, url=excluded.url, text=excluded.text,
    score=excluded.score, by=excluded.by, time=excluded.time,
    descendants=excluded.descendants, type=excluded.type,
    fetched_at=excluded.fetched_at,
    rank=COALESCE(excluded.rank, stories.rank),
    dead=excluded.dead
`

type UpsertStoryParams struct {
	ID          int     `json:"id"`
	Title       string  `json:"title"`
	URL         *string `json:"url"`
	Text        *string `json:"text"`
	Score       int     `json:"score"`
	By          string  `json:"by"`
	Time        int64   `json:"time"`
	Descendants int     `json:"descendants"`
	Type        string  `json:"type"`
	FetchedAt   int64   `json:"fetched_at"`
	Rank        *int    `json:"rank"`
	Dead        bool    `json:"dead"`
}

func (q *Queries) UpsertStory(ctx context.Context, db DBTX, arg UpsertStoryParams) error {
	_, err := db.ExecContext(ctx, upsertStory,
		arg.ID,
		arg.Title,
		arg.URL,
		arg.Text,
		arg.Score,
		arg.By,
		arg.Time,
		arg.Descendants,
		arg.Type,
		arg.FetchedAt,
		arg.Rank,
		arg.Dead,
	)
	return err
}
