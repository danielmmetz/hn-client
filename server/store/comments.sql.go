// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: comments.sql

package store

import (
	"context"
)

const commentExists = `-- name: CommentExists :one
SELECT COUNT(*) FROM comments WHERE id = ?
`

func (q *Queries) CommentExists(ctx context.Context, db DBTX, id int) (int, error) {
	row := db.QueryRowContext(ctx, commentExists, id)
	var count int
	err := row.Scan(&count)
	return count, err
}

const getCommentIDsByStory = `-- name: GetCommentIDsByStory :many
SELECT id FROM comments WHERE story_id = ?
`

func (q *Queries) GetCommentIDsByStory(ctx context.Context, db DBTX, storyID int) ([]int, error) {
	rows, err := db.QueryContext(ctx, getCommentIDsByStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int{}
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByStory = `-- name: GetCommentsByStory :many
SELECT id, story_id, parent_id, by, text, time, dead, deleted, fetched_at
FROM comments WHERE story_id = ?
ORDER BY time ASC
`

func (q *Queries) GetCommentsByStory(ctx context.Context, db DBTX, storyID int) ([]*Comment, error) {
	rows, err := db.QueryContext(ctx, getCommentsByStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.ParentID,
			&i.By,
			&i.Text,
			&i.Time,
			&i.Dead,
			&i.Deleted,
			&i.FetchedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertComment = `-- name: UpsertComment :exec
INSERT INTO comments (id, story_id, parent_id, by, text, time, dead, deleted, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    story_id=excluded.story_id, parent_id=excluded.parent_id,
    by=excluded.by, text=excluded.text, time=excluded.time,
    dead=excluded.dead, deleted=excluded.deleted,
    fetched_at=excluded.fetched_at
`

type UpsertCommentParams struct {
	ID        int     `json:"id"`
	StoryID   int     `json:"story_id"`
	ParentID  *int    `json:"parent_id"`
	By        *string `json:"by"`
	Text      *string `json:"text"`
	Time      int64   `json:"time"`
	Dead      bool    `json:"dead"`
	Deleted   bool    `json:"deleted"`
	FetchedAt int64   `json:"fetched_at"`
}

func (q *Queries) UpsertComment(ctx context.Context, db DBTX, arg UpsertCommentParams) error {
	_, err := db.ExecContext(ctx, upsertComment,
		arg.ID,
		arg.StoryID,
		arg.ParentID,
		arg.By,
		arg.Text,
		arg.Time,
		arg.Dead,
		arg.Deleted,
		arg.FetchedAt,
	)
	return err
}
