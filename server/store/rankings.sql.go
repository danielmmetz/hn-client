// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rankings.sql

package store

import (
	"context"
)

const countRankingsByPeriod = `-- name: CountRankingsByPeriod :one
SELECT COUNT(*) FROM rankings WHERE period = ?
`

func (q *Queries) CountRankingsByPeriod(ctx context.Context, db DBTX, period string) (int, error) {
	row := db.QueryRowContext(ctx, countRankingsByPeriod, period)
	var count int
	err := row.Scan(&count)
	return count, err
}

const deleteRankingsByPeriod = `-- name: DeleteRankingsByPeriod :exec
DELETE FROM rankings WHERE period = ?
`

func (q *Queries) DeleteRankingsByPeriod(ctx context.Context, db DBTX, period string) error {
	_, err := db.ExecContext(ctx, deleteRankingsByPeriod, period)
	return err
}

const getStoriesByPeriod = `-- name: GetStoriesByPeriod :many
SELECT s.id, s.title, s.url, s.text, s.score, s.by, s.time, s.descendants, s.type, s.fetched_at, s.rank, s.dead
FROM rankings r
JOIN stories s ON s.id = r.story_id
WHERE r.period = ?
ORDER BY r.score DESC
LIMIT ? OFFSET ?
`

type GetStoriesByPeriodParams struct {
	Period string `json:"period"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
}

func (q *Queries) GetStoriesByPeriod(ctx context.Context, db DBTX, arg GetStoriesByPeriodParams) ([]*Story, error) {
	rows, err := db.QueryContext(ctx, getStoriesByPeriod, arg.Period, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.URL,
			&i.Text,
			&i.Score,
			&i.By,
			&i.Time,
			&i.Descendants,
			&i.Type,
			&i.FetchedAt,
			&i.Rank,
			&i.Dead,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasActiveRankings = `-- name: HasActiveRankings :one
SELECT COUNT(*) FROM rankings WHERE story_id = ?
`

func (q *Queries) HasActiveRankings(ctx context.Context, db DBTX, storyID int) (int, error) {
	row := db.QueryRowContext(ctx, hasActiveRankings, storyID)
	var count int
	err := row.Scan(&count)
	return count, err
}

const insertRanking = `-- name: InsertRanking :exec
INSERT INTO rankings (story_id, period, score, computed_at) VALUES (?, ?, ?, ?)
`

type InsertRankingParams struct {
	StoryID    int     `json:"story_id"`
	Period     string  `json:"period"`
	Score      float64 `json:"score"`
	ComputedAt int64   `json:"computed_at"`
}

func (q *Queries) InsertRanking(ctx context.Context, db DBTX, arg InsertRankingParams) error {
	_, err := db.ExecContext(ctx, insertRanking,
		arg.StoryID,
		arg.Period,
		arg.Score,
		arg.ComputedAt,
	)
	return err
}
