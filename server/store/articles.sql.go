// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: articles.sql

package store

import (
	"context"
)

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles WHERE story_id = ?
`

func (q *Queries) DeleteArticle(ctx context.Context, db DBTX, storyID int) error {
	_, err := db.ExecContext(ctx, deleteArticle, storyID)
	return err
}

const getArticleByStoryID = `-- name: GetArticleByStoryID :one
SELECT story_id, content, title, excerpt, byline, extraction_failed, fetched_at
FROM articles WHERE story_id = ?
`

func (q *Queries) GetArticleByStoryID(ctx context.Context, db DBTX, storyID int) (*Article, error) {
	row := db.QueryRowContext(ctx, getArticleByStoryID, storyID)
	var i Article
	err := row.Scan(
		&i.StoryID,
		&i.Content,
		&i.Title,
		&i.Excerpt,
		&i.Byline,
		&i.ExtractionFailed,
		&i.FetchedAt,
	)
	return &i, err
}

const upsertArticle = `-- name: UpsertArticle :exec
INSERT INTO articles (story_id, content, title, excerpt, byline, extraction_failed, fetched_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(story_id) DO UPDATE SET
    content=excluded.content, title=excluded.title, excerpt=excluded.excerpt,
    byline=excluded.byline, extraction_failed=excluded.extraction_failed,
    fetched_at=excluded.fetched_at
`

type UpsertArticleParams struct {
	StoryID          int     `json:"story_id"`
	Content          *string `json:"content"`
	Title            *string `json:"title"`
	Excerpt          *string `json:"excerpt"`
	Byline           *string `json:"byline"`
	ExtractionFailed bool    `json:"extraction_failed"`
	FetchedAt        int64   `json:"fetched_at"`
}

func (q *Queries) UpsertArticle(ctx context.Context, db DBTX, arg UpsertArticleParams) error {
	_, err := db.ExecContext(ctx, upsertArticle,
		arg.StoryID,
		arg.Content,
		arg.Title,
		arg.Excerpt,
		arg.Byline,
		arg.ExtractionFailed,
		arg.FetchedAt,
	)
	return err
}
